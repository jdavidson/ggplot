# Contributing
The `ggplot` setup is pretty simple. We favor using files over having many
features packed into 1 file (i.e. all the geoms in 1 file). The reason for
this is in part because we want to make it as easy as possible to contribute
to the project.

There are a few things you should know before you get started. We'll take you
through an example of implementing a new geom. Hopefully this will get you
going in the right direction.


## Getting Started
To start, let's reimplement a geom that we all know and love `geom_point`. It's pretty
straightforward - it's going to take some x and y coordinates and make a 
scatterplot. You can look at the code here: 

```
import matplotlib.pyplot as plt
from .geom import geom

class geom_point(geom):
    VALID_AES = ['x', 'y', 'size', 'color', 'alpha', 'shape', 'marker', 'label', 'cmap']
    
    def plot_layer(self, layer):
        layer = {k: v for k, v in layer.items() if k in self.VALID_AES}
        layer.update(self.manual_aes)
        
        if "size" in layer:
          layer["s"] = layer["size"]
          del layer["size"]
        
        if "cmap" in layer:
          layer["c"] = layer["color"]
          del layer["color"]
        
        plt.scatter(**layer)
```

### Imports
The first thing you probably noticed is the imports. First, we imported `pyplot` as `plt`
since this is the regular convention. `ggplot` uses `pyplot` for (nearly) all plots (as
opposed to axes). This makes things simple and keeps the geoms focused only on doing 1 
thing.

The second thing we import is the `geom` object. We'll go into more detail on this in a 
second. 

```
import matplotlib.pyplot as plt
from .geom import geom
```

### Inheriting from `geom`
As mentioned previously, all of our `geom_*` and `stat_*` (for the time being) inherit
from `geom`. Each of our geoms inherits from the `geom` object. This is going to give 
it the delightful `+` properties that make it possible to magically add layers together.

In addition, it keeps things easy so that when it comes time to render the plot, all of
our plot operations are done using the same type of object.
```
from .geom import geom
```

### Defining the `aes`
A core concept of `ggplot` is the aesthetics, or attributes and properties, of your plot.
There are many types of `aes` and not all will be available for each type of plot. Here
is a working list of valid `aes`:

- x: x-axis value
- y: y-axis value
- color (colour): color of a layer
- shape: shape of a point
- size: size of a point or line
- alpha: transparency level of a point
- xintercept
- ymin: min value for a vertical line or a range of points
- ymax: max value for a vertical line or a range of points
- xmin: min value for a horizonal line
- xmax: max value for a horizonal line
- slope: slope of an abline
- intercept: intercept of an abline

For each geom, you must define the `VALID_AES`. This tells `ggplot` which aesthetics to
ignore for a particular geom -- which makes it super easy to combine plots that have
different aesthetics.

### Handling Layers
This is the only method you need to implement when you're creating a new geom. It's 
actually quite a simple method. `plot_layer` accepts a `layer` object which is just
a dictionary of data that looks like this:
```
example_layer = {
  "x": [1, 2, 3, 4],
  "y": [10, 100, 1000, 10000],
  "color": "red"
}
```
There are a few things you should know about layers;
    - You can expect that incoming discrete variables (i.e. shape or color), will
    come in with only 1 value.
    - You can expect that incoming continuous variables (i.e. x, y) will come in
    as a lists of equal length. 

Unfortunately if you're reading this then you're interested in contributing to
`ggplot` which means you'll need to write some `matplotlib` code. Ironically even though
I developed `ggplot` to stop writing `matplotlib`, I now find myself writing more
`matplotlib` in order to support `ggplot`. In any event, the `matplotlib` plot methods
do not have consistent names for their arguments. As a result, there are time when you'll
  have to edit names of the variables in your layer in order to accomodate `matplotlib`.
You can see here that we're changing the name of the `size` variable to `s` and the 
`color` variable to `c`.

```
if "size" in layer:
  layer["s"] = layer["size"]
  del layer["size"]

if "cmap" in layer:
  layer["c"] = layer["color"]
  del layer["color"]
```

### Constructing the Plot
Making the plot is oftentimes the easiest part of building a geom. The key is the know
which arguments are important for the particular plot you're making. In this case, in order
to make a `geom_point` we need a few basic things:

- x coordinates
- y coordinates
- [optional] color / cmap -- cmap is used for color gradients
- [optional] marker / shape
- [optional] label -- what appears in the legend
- [optional] alpha -- level of transparency
- [optional] size -- size of the point

We need to map each of these arguments to a named argument for the `plt.scatter` function.
Once we've done that, we're going to pass in these arguments using `*args`. Note that for some
plotting methods (such as `plt.plot`), you can't specify certain arguments using `*args` (for 
example x and y).

### That's It
That's really all you have to do to add a geom! It's actually fairly simple. The core `ggplot` 
functions will take care of the layering, faceting, etc. neccessary for advanced plotting.


